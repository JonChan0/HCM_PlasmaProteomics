---
title: "UKB_PlasmaProteomics_TimeInstancing_SensitivityAnalysis"
author: "Jonathan Chan"
date: "2025-04-01"
output: html_document
---

This performs sensitivity analysis on the time instancing i.e the max. lag time from blood sample collection before which diagnosis of HCM is assumed to occur.

```{r}
library(tidyverse)
library(tictoc)
library(ggrepel)
library(ggsignif)
library(car)
library(readxl)
library(limma)

theme_set(theme_classic())

date <- as.POSIXlt(Sys.time(), 'UTC')
date <- strftime(date, "%Y%m%dT%H:%M:%S%z")
date <- str_match(date,'^(\\d+)T')[,2]
```

## Time-Instancing Case Calculator

This is a function used to compute the cases based on the lag time for HCM only.
We assume 0 time lag for individuals who are HF or T2D.

```{r}
hcm_diag_tb <- readRDS('DATA/UKB/PROCESSED/3_TOTAL/ukb_diagnosis_dates_minimum.rds')
bcollection_date <- read_tsv('DATA/UKB/RAP/Cases/2024_02_09_allUKB_BloodCollection_Time.tsv')%>%
  dplyr::rename(ID=eid, bcollection_date_i0=p21842_i0) %>%
  mutate(bcollection_date_i0=as_date(bcollection_date_i0))
hcm_diag_tb <- left_join(hcm_diag_tb, bcollection_date, 'ID')
  
hcm_case_instance_calculator <- function(input_tb, output_name, threshold_date='bcollection_date_i0', 
                                         lagtime=5, #Lag time defined in years
                                         output_folder='DATA/UKB/PROCESSED/5_TimeInstancing/') { 
  
  output_tb <- input_tb %>%
    mutate(case = ifelse(time_length(min_diag_date - eval(parse(text=threshold_date)), unit='year') <= lagtime |  #Assign 5Y status if their minimum date of diagnosis was within n years after attendance. NB This includes i0 cases because they have a time_length of negative because min_diag_Date < date_attend_i0
                                    time_length(death_date - eval(parse(text=threshold_date)), unit='year') <=lagtime, T,F)) #OR if they had mention of death with ICD10 code of interest & died within n years of attendance
    
  print(str_c('There are',nrow(filter(output_tb, case==T)), output_name, 'cases in the UKB who satisfy', lagtime, 'Y criteria', sep=' ' ))
  
  if(!dir.exists(output_folder)){dir.create(output_folder, recursive=T)}
  write_tsv(filter(output_tb, case==T)%>% select(ID), str_c(output_folder, 'ukb_rap_',output_name, '_20240209_',lagtime,'Ycases.tsv'))
  
  output_tb <- filter(output_tb, case==T)%>% select(ID) #Only output the filtered HCM cases
  
  return(output_tb)
}
```

```{r}
overall_tb_builder <- function( ukb_cases, #HCM cases in UKB from the particular instance
                                hcm_instance, #Name of the instance
                                ukb_pp_list, #List of plasma proteins to compare
                                ukb_basic_cov_filepath='DATA/UKB/PROCESSED/20240209_ukb_age_sex_htwt_10pcs_dbp_t2d_smoking_cov.tsv',  
                                ukb_rcmm_cov_filepath='DATA/UKB/PROCESSED/20240209_ukb_rcmm_cov.tsv',
                                ukb_pp_filepath='DATA/UKB/RAP/PP/ukb_allpp_i0.tsv', 
                                pp_scaling='ranknorm',include_nonCM_panels=T, rcmm_cov=T){
  
  #Import in the plasma protein data
  ukb_pp_data <- read_tsv(ukb_pp_filepath, col_types=rep('n',3006))%>% #All numeric columns
  select(-`...1`) %>%
  select(contains('instance_0')) %>% #It contains some instance 2 columns for some reason
  rename_with(~str_match(.,'\\.(.+)')[,2]) %>%
  filter(if_any(!'eid', ~!is.na(.))) %>%
  mutate(non_na_count = rowSums(!is.na(.))-1) %>% #-1 for eid is non-NA
  #filter(non_na_count > 2) %>%
  mutate(instance=0) %>%
  select(eid, instance, ukb_pp_list$ukb_fieldname_equivalent) #Filter for only plasma proteins in the ukb_pp_list
  
  #Import in covariate data
  ukb_20240209_snptest_covariates <- read_tsv(ukb_basic_cov_filepath)
  if(isTRUE(rcmm_cov)){ukb_20240209_rcmm_cov <- read_tsv(ukb_rcmm_cov_filepath)}
  
  #Combine the covariate + pp data
  ukb_pp_hcm_cov2 <- ukb_pp_data %>%
  mutate(hcm = ifelse(eid %in% ukb_cases$ID, T, F)) %>%
  left_join(ukb_20240209_snptest_covariates,by=c('eid'='ID')) %>%
  select(eid, instance, hcm:t2d, everything()) %>%
  relocate(bmi, .after='weight') %>% 
  filter(if_all(age:t2d, ~!is.na(.))) %>%  #Filter out individuals who have NA value for covariates 
  filter(if_any(all_of(ukb_pp_list$ukb_fieldname_equivalent), ~!is.na(.))) %>% #Filter out individuals who have no non-NA values for all panel proteins 
  select(where(~any(!is.na(.)))) #Filter for plasma proteins which actually have non-NA values 
  
  if(isTRUE(rcmm_cov)){
    ukb_pp_hcm_cov2 <- ukb_pp_hcm_cov2 %>%
    left_join(ukb_20240209_rcmm_cov,by=c('eid'='ID')) %>%
    select(eid, instance, hcm:t2d, Townsend:ldl, everything()) %>% #52092 individuals
    select(-hdl) %>%  #Ignore HDL for now due to loss of non-NA individuals
    filter(if_all(c(Townsend,eGFR,ldl), ~!is.na(.)))#Filter out individuals who have NA value for covariates
  }
  
  print(str_c('Number of HCM cases in instance ', hcm_instance, ' = ',sum(ukb_pp_hcm_cov2$hcm)))
  print(str_c('Number of total individuals with non-NA covariates + at least one non-NA plasma proteins in ', hcm_instance, ' = ',nrow(ukb_pp_hcm_cov2)))
  
  return(ukb_pp_hcm_cov2)
}
```
## Limma
```{r}
limma_dpe <- function(input_tb, protein, predictor_vars='hcm', covar=c('age','sex','bmi','pc1','pc2','pc3','pc4','pc5','dbp','t2d','smoking'), ivnormalise=T){
  
  input_tb <- filter(input_tb, !is.na(!!sym(protein))) #Exclude rows with NA values in the response variable
  
  if(isTRUE(ivnormalise)){
    input_tb[[protein]] <- RNOmni::RankNorm(input_tb[[protein]])
  }
  
  #Separate into pheno_df for covariates and predictors and npx_df containing the NPX value for the protein over all individuals
  pheno_df <- select(input_tb, all_of(predictor_vars),all_of(covar)) %>%
    mutate(across(all_of(predictor_vars), ~factor(.)))
  npx_df <- select(input_tb, !!sym(protein))
  
  #Need to define the formula i.e model and the model matrix
  formula <- str_c('~0 +',
                   str_c(predictor_vars,collapse='+'),
                   '+',str_c(covar, collapse='+'))
  design <- model.matrix(eval(parse(text=formula)), pheno_df)
  
  #Need to create the matrix array for limma i.e rows = proteins; columns = samples via t() for transpose
  #Perform the model fitting using weighted least-squares
  lin_model <- lmFit(t(npx_df), design)
  
  #To obtain log-fold changes between groups of the predictor_var i.e hcmTRUE vs. hcmFALSE, you need to obtain the contrast of this fitted linear model
  if(predictor_vars=='hcm'){
      contr <- makeContrasts(hcmTRUE - hcmFALSE, levels = design)
  } else if (predictor_vars=='hf'){
    contr <- makeContrasts(hfTRUE - hfFALSE, levels = design)
  }else if (predictor_vars=='rare'){
    contr <- makeContrasts(rareTRUE - rareFALSE, levels = design)
  }
  
  # Estimate contrast for the protein of interest
  tmp <- contrasts.fit(lin_model, contr)
  
  # Empirical Bayes smoothing of standard errors (shrinks standard errors that are much larger or smaller than those from other proteins towards the average standard error)
  tmp <- eBayes(tmp)
  
  #Return results for that particular protein
  top.table <- topTable(tmp, sort.by = "P", n = Inf)
  results <-  as_tibble(top.table) %>%
    select(-5) %>%
    mutate(pp=protein) %>%
    select(pp, everything())
  
  return(results)
}
```

## Summary Plotting
```{r}
summary_plotter_limma <- function(input_tb, output_label='ukb_allpanel', predictor = 'HCM status', output_path=str_c('PLOTS/UKB/1_Case_vs_Control/2_Limma/',instance), pval='bonferroni', fdr_threshold = 0.05, test='Empirical Bayes moderated t-test',xlabel='Log2(Fold-Change)', xlimits=c(-1,2),ylimits=c(0,40), specific_label=F){
  
  if (pval=='fdr'){
    input_tb <- input_tb %>%
      mutate(P.Value = p.adjust(P.Value, 'fdr'))
    
    pval_threshold <- fdr_threshold
  } else if(pval=='bonferroni'){
    pval_threshold <- 0.05/nrow(input_tb)
    
  } else if (is.numeric(pval)){ #i.e if defining own pvalue threshold to use
    pval_threshold <- pval
  }
  
  if(isFALSE(specific_label)){
    input_tb <- input_tb %>% #Only label the ones which reach significance
      mutate(Label=ifelse(P.Value < pval_threshold,Gene, ''),
           MTC_significant = ifelse(P.Value < pval_threshold, T, F)) %>%
      arrange(Label)
  } else {
    input_tb <- input_tb %>%
      mutate(MTC_significant = ifelse(Label=='', F, T)) %>%#Just for downstream code purposes to label some specific points
      arrange(Label)
  }

 
  #Base plot
  summary_cont_plot <- ggplot(input_tb, aes(x=logFC, y=-log10(P.Value), col=MTC_significant))+
    geom_vline(xintercept=0, linetype='dashed')+
    geom_point()+
    scale_colour_manual(name=ifelse(isFALSE(specific_label),'MTC Significant','PP of Interest'),values=c('FALSE'='grey','TRUE'='red'))+
    geom_text_repel(aes(label=Label), nudge_y=3 ,
                    #nudge_x=0.5,
                    force =5, max.overlaps=100)+
    labs(col='Phenotype',shape='Predictor')+
    scale_x_continuous(n.breaks=10, limits=xlimits)+
    scale_y_continuous(limits=ylimits)+
    xlab(xlabel)+
    ylab('-log10(p-value)')+
    labs(title=str_c('Summary plot of ', test,' tests for ',length(unique(input_tb$pp)), ' plasma proteins for ', predictor, ' predictor variable'))
  
  
  #Adjust the plot depending on the multiple testing correction
  if (pval=='bonferroni'){
    
    summary_cont_plot <- summary_cont_plot +
      geom_hline(yintercept=-log10(0.05/nrow(input_tb)), linetype='dashed')+
      labs(caption=str_c('Bonferroni-corrected p-value threshold = ',signif(0.05/nrow(input_tb),3)))
    
  } else if (pval =='fdr'){
    summary_cont_plot <- summary_cont_plot +
      geom_hline(yintercept=-log10(pval_threshold), linetype='dashed')+
      ylab('-log10(Adjusted p-value)')+
      labs(caption=str_c( fdr_threshold*100, '% FDR correction applied for multiple testing burden'))
  } else if (is.numeric(pval)){
    summary_cont_plot <- summary_cont_plot +
      geom_hline(yintercept=-log10(pval_threshold), linetype='dashed')+
      labs(caption=str_c('Applied p-value threshold = ',signif(pval_threshold,3)))
  }
  
  print(summary_cont_plot)
  ggsave(str_c(output_path,output_label,'_summary_plot_',pval,'.png'),summary_cont_plot,dpi=600, width=12, height=6)
  
  #Also output a MAplot 
  ma_plot <- ggplot(input_tb, aes(x = log10(abs(AveExpr)), y = logFC)) +
    geom_point(aes(col= MTC_significant), alpha=0.5) +
    geom_text_repel(aes(label=Label))+
    labs(x = "Log10(Mean Normalised NPX)", y = xlabel) +
    scale_colour_manual(name='MTC Significant',values=c('FALSE'='grey','TRUE'='red'))+
    labs(title=str_c('MA plot for ', test, ' in UKB plasma proteins CM panel'))

  print(ma_plot)
  ggsave(str_c(output_path,output_label,'_ma_plot_',pval,'.png'),ma_plot,dpi=600, width=9, height=6)
  
  return(input_tb)

}
```


# Main
```{r}
#Earliest collection time for HCM case in UKB = ~ 2006 and end of dataset = 2024 so 18 years is max
# lagtimes <- c(seq(0,4,2),5,seq(6,18,2))
lagtimes <- c(2,4,seq(6,16,2))
ukb_pp_list <- read_tsv('DATA/UKB/PROCESSED/ukb_pp_list_allpanel.tsv')
hf_eid <- read_tsv('DATA/UKB/PROCESSED/1_I0/ukb_rap_HF_20240209_i0cases.tsv')


main <- function(lagtime,  #Lagtime to test in years
                  ukb_pp_list, #PPs to include in analysis,
                  hf_eid, #IDs of HF cases (i0)
                  ukb_basic_cov_filepath='DATA/UKB/PROCESSED/20240209_ukb_age_sex_htwt_10pcs_dbp_t2d_smoking_cov.tsv',  
                  ukb_rcmm_cov_filepath='DATA/UKB/PROCESSED/20240209_ukb_rcmm_cov.tsv',
                  ukb_pp_filepath='DATA/UKB/RAP/PP/ukb_allpp_i0.tsv', 
                  pp_scaling='ranknorm',
                  rcmm_cov=T,
                  include_nonCM_panels=T,
                  cc_output_basepath = 'OUTPUT/UKB/PLOTS/1_Case_vs_Control/2_Limma/0_TimeInstancing/'){
  
  hcm_cases <- hcm_case_instance_calculator(hcm_diag_tb, 'HCM', lagtime=lagtime)
  
  ukb_pp_cov_hcm <- overall_tb_builder(hcm_cases, #HCM cases in UKB from the particular instance
                                str_c(lagtime, 'Y', collapse = ''), #Name of the instance
                                ukb_pp_list, #List of plasma proteins to compare
                                ukb_basic_cov_filepath,  
                                ukb_rcmm_cov_filepath,
                                ukb_pp_filepath, 
                                pp_scaling,include_nonCM_panels, rcmm_cov)
  
  pp <- ukb_pp_list$ukb_fieldname_equivalent[ukb_pp_list$ukb_fieldname_equivalent %in% colnames(ukb_pp_cov_hcm)] %>%  #In case any PP are removed due to lack of non-NA values
  unique()
  
  #Run case-control analysis for HCM (including HF) vs. non-HF (i0) and non-HCM (lagtime) controls
  #Only run this CC analysis (and not subgroup ones) because limma is a bit slow
  
  cc_tb <- ukb_pp_cov_hcm %>%
    mutate(hcm = case_when(eid %in% hcm_cases$ID ~ T, #HCM cases independent of HF status
                           !eid %in% hcm_cases$ID & !eid %in% hf_eid$ID ~ F, #Non-HF non-HCM controls
                           T~NA)) %>% #non-HCM and HF 
    filter(!is.na(hcm))
  
  print(str_c('At lagtime ', lagtime, 'Y, number of HCM cases (incl. those with HF) = ', sum(cc_tb$hcm==T), ' and non-HCM/HF controls = ', sum(cc_tb$hcm==F)))
  
  if (isTRUE(rcmm_cov)){  #If using the extended covariate list suggested by Rob Clarke and Mohsen
    extra_folders <- 'rcmm_cov/'
    covars <- c('age','sex','bmi','pc1','pc2','pc3','pc4','pc5','dbp','t2d','smoking','Townsend','eGFR', 'ldl')
  } else {
    covars <- c('age','sex','bmi','pc1','pc2','pc3','pc4','pc5','dbp','t2d','smoking')
  }
  if(isTRUE(include_nonCM_panels)){ extra_folders <- str_c(extra_folders, 'allpanels/')} 
  path <- str_c(cc_output_basepath,'/HCM/', extra_folders) #Define the folder for output of plots and tabular data
  if(!dir.exists(path)){dir.create(path, recursive=T)}
  
  limma_hcm <- map(pp, ~limma_dpe(cc_tb,., covar=covars)) %>% bind_rows()
  
  limma_hcm <- left_join(limma_hcm, select(ukb_pp_list, Gene=Target, ukb_fieldname_equivalent), by=c('pp'='ukb_fieldname_equivalent')) %>% unique()
  write_tsv(limma_hcm, str_c(path,lagtime, 'Y_lag_limma_results.tsv'))
  print(str_c('Written output limma_results.tsv for lagtime ', lagtime, 'Y'))
  
  pp_vs_hcm_marginal_bonferroni_summarytb_limma <- summary_plotter_limma(limma_hcm, output_label = str_c(lagtime, 'Y_lag_allpp_vs_hcm'),predictor = 'HCM status',output_path=path, xlimits=c(-1,2),ylimits=c(0,50)) 
  
  #Also for 5%FDR and 1%FDR
  pp_vs_hcm_marginal_fdr5_summarytb_limma <- summary_plotter_limma(limma_hcm, output_label = str_c(lagtime, 'Y_lag_allpp_vs_hcm'),predictor = 'HCM status',output_path=path, pval = 'fdr', xlimits=c(-1,2),ylimits=c(0,50)) 
  
  rm(ukb_pp_cov_hcm, path)
  
  return(limma_hcm)
}

walk(lagtimes, ~main(., ukb_pp_list, hf_eid))
```

