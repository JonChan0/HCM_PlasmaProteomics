---
title: "Univariate Survival Analysis - UKB PPP"
author: "Jonathan Chan"
date: "`r Sys.Date()`"
output: 
  html_document:
    code_folding: hide   
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(readxl)
library(viridis)
library(ggtext)
library(plotly)
library(ggrepel)
library(survival)
library(survminer)
rm(list=ls())

theme_set(theme_classic())
```

This performs univariate survival analysis using categorical variables on the 103 HCM cases within the UKB PPP subset.

## Import Predictor Data

```{r}
ukb_pp_hcm_cov2 <- read_tsv('../data/UKB/PROCESSED/ukb_cmpanelpp_hcm_covariates_bp_t2d_smoking') %>%
  filter(hcm==T) %>%
  mutate(smoking=factor(smoking, levels=c('Never','Previous','Current')))
```

## Import Outcome Data

This looks at the number of events which occur within the 103 HCM cases who have plasma proteomic data.

For the plasma proteomic severity analysis, you will have to perform left truncation of events that happen prior to the attendance of assessment centre at instance 0 (i.e when blood samples taken).

```{r}
ukb_pp_hcm_outcome <- read_tsv('../../../HCM_Severity/DATASETS/UKB/RAP/Outcomes/Processed/allukb_outcome_ages.tsv') %>%
  filter(ID %in% filter(ukb_pp_hcm_cov2, hcm==T)$eid) 

#Perform left truncation
ukb_pp_hcm_outcome <- ukb_pp_hcm_outcome %>%
  mutate(across(.cols=arrest_age_i46:HeartTransplant_mergeage, ~ifelse(.<age_attend_i0, NA,.)))%>%
  mutate(overallcomp_status = as.numeric(if_any(.cols=arrest_age_i46:HeartTransplant_mergeage, ~!is.na(.)))) #Add censoring status where event = 1 and censored (i.e lost to follow-up or end date i.e 2024-02-09) = 0

sum(ukb_pp_hcm_outcome$overallcomp_status) #65 of the 103 have events in the overall composite after left truncating at attending recruitment centre!

knitr::kable(tibble('Variable'=colnames(ukb_pp_hcm_outcome),'NonNA_Counts'=map_int(ukb_pp_hcm_outcome, ~sum(!is.na(.)))) %>% arrange(desc(NonNA_Counts)))

#Derive the age for overall composite
ukb_pp_hcm_outcome <- ukb_pp_hcm_outcome %>%
  rowwise() %>%
  mutate(overallcomp_age = min(c_across(arrest_age_i46:HeartTransplant_mergeage),na.rm=T)) %>% #Take the earliest date of any occurrence in the overall composite
  mutate(overallcomp_age = ifelse(overallcomp_status==T, overallcomp_age, censoring_age)) %>% #If censored i.e not event, then take the censoring age. 
  ungroup()
```

Repeat for the other composite outcomes beyond the overall composite i.e VA and HF composites.

```{r}
#For the ventricular arrhytmia composite
ukb_pp_hcm_outcome <- ukb_pp_hcm_outcome %>%
  mutate(vacomp_status = as.numeric(if_any(c('arrest_age_i46','scd_age_i46.1','ICDImplant_mergeage'), ~!is.na(.))))%>%
  rowwise() %>%
  mutate(vacomp_age = min(c_across(c('arrest_age_i46','scd_age_i46.1','ICDImplant_mergeage')),na.rm=T)) %>% #Take the earliest date of any occurrence in the composite
  mutate(vacomp_age = ifelse(vacomp_status==T, vacomp_age, censoring_age)) %>% #If censored i.e not event, then take the censoring age. 
  ungroup()

#For the HF composite
ukb_pp_hcm_outcome <- ukb_pp_hcm_outcome %>%
  mutate(hfcomp_status = as.numeric(if_any(c('hf_age_i50','HeartTransplant_mergeage'), ~!is.na(.))))%>%
  rowwise() %>%
  mutate(hfcomp_age = min(c_across(c('hf_age_i50','HeartTransplant_mergeage')),na.rm=T)) %>% #Take the earliest date of any occurrence in the composite
  mutate(hfcomp_age = ifelse(hfcomp_status==T, hfcomp_age, censoring_age)) %>% #If censored i.e not event, then take the censoring age. 
  ungroup()

```

```{r}
#Merge the covariates with the outcome
ukb_tb <- ukb_pp_hcm_outcome %>%
  left_join(ukb_pp_hcm_cov2, by=c('ID'='eid'))

#rm(ukb_pp_hcm_cov2, ukb_pp_hcm_outcome)
```



## Continuous Variable Binning

This enables you to select continuous variables to bin into groups/categorical variables for plotting of Kaplan Meier analyses.

This is required for all the 

```{r}
contvar_binner <- function(input_tb, variable, threshold, signif=F){ #Assumes split into two groups
  newcolname <- str_c(variable,'_categorical')
  
  output <- mutate(input_tb,
                   temp=ifelse(eval(parse(text=variable)) >= threshold, str_c('>= ', threshold), str_c('< ', threshold)))
  colnames(output)[ncol(output)] <- newcolname
  
  return(output)
}

ukb_tb <- contvar_binner(ukb_tb, 'ntprobnp', signif(quantile(ukb_tb$ntprobnp,probs=0.75,na.rm=T),3)) %>%
  contvar_binner('hrc',signif(quantile(ukb_tb$hrc,probs=0.75,na.rm=T),3))
```


## Kaplan Meier Survival Curves

This conducts some univariate analysis on categorical variables by plotting Kaplan-Meier survival curves for each category and performing log-rank test (non-parametric but also univariate).

The p-values and confidence intervals for difference between the groups on the plots arises from the regular log-rank test.

Such variables include

- Sex

I also change the y-axis to output cumulative incidence of events as well as cumulative hazard (number of events that would be expected for each individual by time t if the event were a repeatable process).

```{r kaplan_meier, fig.width=9, fig.height=10, message=F, warning=F}
km_survival_curv_plotter <- function(input_tb, categorical_var, status, outcome_var, plot_output_folder){ #outcome_var = Define the column for age at first occurence of selected outcome of interest
  
  print(str_c('Plotting Kaplan Meier survival curves for', deparse(substitute(categorical_var)),sep=' '))
    
    plot_types <- c('pct','event', 'cumhaz')
    
    for (type in plot_types){
    
      params <- list(fun.time = substitute(outcome_var),
    fun.event = substitute(status),
    grouping = substitute(categorical_var), 
    fun.dat = substitute(input_tb),
    type=type)
          
          plot <- substitute(ggsurvplot(
      fit= survfit(Surv(time = fun.time, event = fun.event) ~ grouping, data = fun.dat),
      fun=type,
      pval=T, conf.int=T, risk.table='abs_pct',risk.table.col='strata',linetype='strata', surv.median.line='hv',xlab='Age',ncensor.plot=T), params)
    
    plot <- eval.parent(plot)
  
    print(plot)
    
    pdf(str_c(plot_output_folder,deparse(substitute(categorical_var)),'_kaplan_',type,'.pdf'), width=12, height=9)
    print(plot, newpage=F)
    dev.off()
    }
}
```


```{r kaplan_meier, fig.width=9, fig.height=10, message=F, warning=F}
outcomes_of_interest <- c('1_VA','2_HF','3_OV')
plotpaths <- str_c('../PLOTS/UKB/4_SURVIVAL/1_UNIVARIATE_KM/', outcomes_of_interest,'/')

#Run for UKB - Overall Composite
km_survival_curv_plotter(ukb_tb,sex,overallcomp_status, overallcomp_age, plotpaths[3]) #Using sex
km_survival_curv_plotter(ukb_tb,ntprobnp_categorical,overallcomp_status,overallcomp_age, plotpaths[3]) #Using top 25% vs. bottom 75% of NTproBNP
km_survival_curv_plotter(ukb_tb,hrc_categorical,overallcomp_status,overallcomp_age, plotpaths[3]) #Using top 25% vs. bottom 75% of HRC

#Run for UKB - HF Composite
km_survival_curv_plotter(ukb_tb,sex,hfcomp_status, hfcomp_age, plotpaths[2]) #Using sex
km_survival_curv_plotter(ukb_tb,ntprobnp_categorical,hfcomp_status,hfcomp_age, plotpaths[2]) #Using top 25% vs. bottom 75% of NTproBNP
km_survival_curv_plotter(ukb_tb,hrc_categorical,hfcomp_status,hfcomp_age, plotpaths[2]) #Using top 25% vs. bottom 75% of HRC

#Run for UKB - VA Composite
km_survival_curv_plotter(ukb_tb,sex,vacomp_status, vacomp_age, plotpaths[1]) #Using sex
km_survival_curv_plotter(ukb_tb,ntprobnp_categorical,vacomp_status,vacomp_age, plotpaths[1]) #Using top 25% vs. bottom 75% of NTproBNP
km_survival_curv_plotter(ukb_tb,hrc_categorical,vacomp_status,vacomp_age, plotpaths[1]) #Using top 25% vs. bottom 75% of HRC
```
# Cox Regression

This is used to model the survival function (via the hazard function) for event composite Y with regards to covariates + plasma protein X (i.e marginal models).

I will limit the plasma proteins to a select few which passed the Bonferroni correction e.g

- NTproBNP: positive control
- HRC: novel biomarker

## Univariate Cox Regression

This applies Cox regression to each of the predictors individually.

To interpret the summary results:

- z refers to Wald test statistic (coef/se(coef)) to evaluate if the beta i.e coefficient is statistically significantly different from 0.
- p-value refers to Wald-test derived p-value

- Coefficient value and exp(coef) i.e hazard ratio reflects the change in hazard with each unit increase in predictor.
  * Hazard ratio can be interpreted as e.g hazard ratio of 0.59 means hazard reduced by 41% while hazard ratio of 1.41 means hazard increased by 41%.
- Confidence intervals of hazard ratios also given.

- Concordance i.e C-statistic is ~ AUC in that values of c near 0.5 indicate that the predictions are no better than a coin flip in determining which patient will live longer. Values near 1 indicate that the risk scores are good at determining which of two patients will have the disease first.
  * Crudely put, concordance shows your ability to predict who of a pair will die sooner, but not necessarily how much sooner or what proportion of the variance of event times is explained by the model.

- Global statistical significance of model (i.e for overall model including all predictors)
  * LRT preferred at smaller sample sizes but all 3x tests are asymptotically equivalent at large N

```{r univariate_cox, message=F, warning=F}
coxph_univariate <- function(input_tb, predictor_var,status, outcome_var){
  
    params <- list(fun.time = substitute(eval(parse(text=outcome_var))),
    fun.event = substitute(eval(parse(text=status))),
    grouping = substitute(eval(parse(text=predictor_var))), 
    data = substitute(input_tb))
    
    coxph <- substitute(coxph(Surv(fun.time,fun.event)~grouping, data), params)
    coxph <- eval.parent(coxph)
    
    print(str_c('Univariate Cox Regression performed on ', predictor_var, ' variable on ', outcome_var))
    
    x <- summary(coxph)
    #print(x)
    
    p.value<-signif(x$wald["pvalue"], digits=3)
    wald.test<-signif(x$wald["test"], digits=3)
    beta<-signif(x$coef[1], digits=3);#coeficient beta
    se_beta <- signif(x$coef[3], digits=3)
    HR <-signif(x$coef[2], digits=3);#exp(beta)
    HR.confint.lower <- signif(x$conf.int[,"lower .95"], 3)
    HR.confint.upper <- signif(x$conf.int[,"upper .95"],3)
    res<-c(beta, se_beta, HR, HR.confint.lower, HR.confint.upper, wald.test, p.value)
    names(res)<-c("beta", 'se_beta', "HR", "Lower_95CI_HR","Upper_95CI_HR", "wald.test", 
                  "p.value")
    
    return(res)
}


```


```{r univariate_cox_ukb, message=F, warning=F}
#For UKB
covariates <- c('sex','bmi','pc1','pc2','pc3','pc4','pc5','dbp','smoking','t2d')
pp <- c('ntprobnp','hrc')
statuses <- c('vacomp_status','hfcomp_status','overallcomp_status')
surv_ages <- c('vacomp_age','hfcomp_age','overallcomp_age')

univariate_cox_results <- c(
  map(pp, ~coxph_univariate(ukb_tb,.,statuses[1],surv_ages[1])),
  map(pp, ~coxph_univariate(ukb_tb,.,statuses[2],surv_ages[2])),
  map(pp, ~coxph_univariate(ukb_tb,.,statuses[3],surv_ages[3]))
)

names(univariate_cox_results) <- (expand_grid(pp,surv_ages) %>% mutate(surv_ages = factor(surv_ages, levels=c('vacomp_age','hfcomp_age','overallcomp_age'))) %>% arrange(surv_ages) %>% mutate(name = str_c(pp, surv_ages, sep='_x_')))$name
```

I also plot the results all together on a single plot of -log10(pvalue) vs. hazard ratio.

```{r univariate_plot, fig.width=9, fig.height=6}

univariate_coxph_plotter <- function(univariate_results, plot_output_path, output_name, outcome_levels=c('VA','HF','OVERALL'), FDR=5){
  
  univariate_tb <- enframe(univariate_results)%>%
    unnest(value) %>%
    mutate(metric=rep(c("beta", 'se_beta', "HR", "Lower_95CI_HR","Upper_95CI_HR", "wald.test", 
                    "p.value"),length(univariate_results))) %>%
    pivot_wider(names_from=metric, values_from=value) %>%
    dplyr::rename(var=name) %>%
    mutate(label=var) %>%
    #mutate(label=predictors_xlabel_tb$Label[match(var, predictors_xlabel_tb$Variable)])
    arrange(label) %>%
    mutate(predictor=str_to_upper(str_match(label,'(.+)_x_')[,2])) %>%
    mutate(outcome = factor(
      str_to_upper(str_match(label,'_x_(.+)comp_age')[,2]),levels=outcome_levels, ordered=T
    ))
  
  if (!is.numeric(FDR)){ #Apply Bonferroni
    pval_threshold = 0.05/length(univariate_results)
    mtc <- 'Bonferroni'
  } else{
    univariate_tb <- mutate(univariate_tb, p.value=p.adjust(p.value, method='BH'))
    pval_threshold <- FDR/100
    mtc <- str_c('FDR ',FDR, '%',sep='')
  }

  univariate_plot <- ggplot(univariate_tb, aes(HR,-log10(p.value)))+
    geom_vline(xintercept=1, linetype='dashed',alpha=0.5)+
    geom_hline(yintercept=-log10(pval_threshold), linetype='dashed', alpha=0.5)+
    geom_point(aes(col=predictor, shape=outcome),alpha=0.75)+
    geom_errorbar(aes(xmin=Lower_95CI_HR, xmax=Upper_95CI_HR,col=predictor, shape=outcome),alpha=0.75)+
    geom_text_repel(aes(label=HR))+
    scale_colour_brewer(name='Predictor',palette='Dark2')+
    scale_shape_discrete(name='Outcome')+
    xlab('Hazard Ratio')+
    ylab(ifelse(mtc=='Bonferroni','-log10 (Wald-test p value)', '-log10 (Adjusted Wald-test p value)'))+
    scale_x_continuous(n.breaks=10)+
    labs(title=str_wrap(str_c('Univariate Cox Regression analysis for ', length(univariate_results), ' tests')),caption=str_c(mtc, ' p-value Threshold Indicated; Error Bars = 95% CI'))+
    theme(legend.position="bottom")+
     guides(col=guide_legend(nrow=1, byrow=TRUE)) 
  
  print(univariate_plot)
  ggsave(str_c(plot_output_path, 'cox_univariate_', output_name,'.png'), dpi=600, width=9, height=6)
  
  return(univariate_tb)
}

univariate_coxph_plotter(univariate_cox_results, '../PLOTS/UKB/4_SURVIVAL/2_COXPH/', 'ntprobnp_hrc_alloutcomes_fdr5')
univariate_coxph_plotter(univariate_cox_results, '../PLOTS/UKB/4_SURVIVAL/2_COXPH/', 'ntprobnp_hrc_alloutcomes_bonferroni', FDR=F)
```


## Multivariate Cox Regression

Here I perform multivariate Cox regression using covariates and with each of the plasma proteins of interest modelled marginally.

```{r multivariate_cox, message=F, warning=F}
multivariate_cox <- function(input_tb, marginal_predictor, covariates, status, outcome_var, outcome_levels=c('VA','HF','OVERALL'), return_predictor_results_only=T){ #Return only the coefficient and p-values for the marginal_predictor
  
  x <- str_c(c(covariates,marginal_predictor), collapse='+')
  y <- str_c('Surv(',outcome_var,',',status,')')
  formula <- as.formula(paste(y,'~',x))
  
  multivariate_cox <- coxph(formula, data=input_tb)
  print(summary(multivariate_cox))
  
  x<- summary(multivariate_cox)
  
  if(isFALSE(return_predictor_results_only)){
  
  p.value<-signif(x$coef[1:nrow(x$coef),5], digits=3)
  beta<-signif(x$coef[1:nrow(x$coef),1], digits=3);#coeficient beta
  HR <-signif(x$coef[1:nrow(x$coef),2], digits=3);#exp(beta) = hazard ratio
  HR.confint.lower <- signif(x$conf.int[,"lower .95"], 3)
  HR.confint.upper <- signif(x$conf.int[,"upper .95"],3)
  se_beta <- signif(x$coef[1:nrow(x$coef),3], digits=3)
  vars <- rownames(x$coef)
    
  } else{
      p.value<-signif(x$coef[nrow(x$coef),5], digits=3)
  beta<-signif(x$coef[nrow(x$coef),1], digits=3);#coeficient beta
  HR <-signif(x$coef[nrow(x$coef),2], digits=3);#exp(beta) = hazard ratio
  HR.confint.lower <- signif(x$conf.int[,"lower .95"][nrow(x$coef)], 3)
  HR.confint.upper <- signif(x$conf.int[,"upper .95"][nrow(x$coef)],3)
  se_beta <- signif(x$coef[nrow(x$coef),3], digits=3)
  vars <- rownames(x$coef)[nrow(x$coef)]

  }
  
  res<-bind_cols(vars,beta, se_beta, HR, HR.confint.lower, HR.confint.upper, p.value) %>%
    mutate(predictor=str_to_upper(vars)) %>%
    mutate(outcome = factor(
      str_to_upper(str_match(outcome_var,'(.+)comp_age')[,2]),levels=outcome_levels, ordered=T
    ))
  
  names(res)<-c('var',"beta",'se_beta', "HR", "Lower_95CI_HR","Upper_95CI_HR", 
            "p.value", 'predictor','outcome')
  
  return(res)
}

#Run marginal Cox regression models
multivariate_cox_results <- c(
  map(pp, ~multivariate_cox(ukb_tb,.,covariates,statuses[1],surv_ages[1])),
  map(pp, ~multivariate_cox(ukb_tb,.,covariates,statuses[2],surv_ages[2])),
  map(pp, ~multivariate_cox(ukb_tb,.,covariates,statuses[3],surv_ages[3]))
) %>%
  bind_rows()

#Run joint Cox regression models (i.e all plasma proteins modelled together)
#Evaluate pairwise correlation between NTproBNP and HRC
cor(ukb_tb$ntprobnp, ukb_tb$hrc, method='spearman', use='pairwise.complete.obs')
#0.6 correlation so Cox regression not suitable model for such collinearity

```
#### Multivariate Summary Plotting

Now plot a summary plot of the results for each predictor.

```{r multivariate_cox_plotter, fig.width=9, fig.height=6, message=F,warning=F}

multivariate_coxph_plotter <- function(multivariate_results, plot_output_path, output_name, FDR=5){
  
  if (!is.numeric(FDR)){ #Apply Bonferroni
    pval_threshold = 0.05/nrow(multivariate_results)
    mtc <- 'Bonferroni'
  } else{
    multivariate_results <- mutate(multivariate_results, p.value=p.adjust(p.value, method='BH'))
    pval_threshold <- FDR/100
    mtc <- str_c('FDR ',FDR, '%',sep='')
  }

  multivariate_plot <- ggplot(multivariate_results, aes(HR,-log10(p.value)))+
    geom_vline(xintercept=1, linetype='dashed',alpha=0.5)+
    geom_hline(yintercept=-log10(pval_threshold), linetype='dashed', alpha=0.5)+
    geom_point(aes(col=predictor, shape=outcome),alpha=0.75)+
    geom_errorbar(aes(xmin=Lower_95CI_HR, xmax=Upper_95CI_HR,col=predictor, shape=outcome),alpha=0.75)+
    geom_text_repel(aes(label=HR))+
    scale_colour_brewer(name='Predictor',palette='Dark2')+
    scale_shape_discrete(name='Outcome')+
    xlab('Hazard Ratio')+
    ylab(ifelse(mtc=='Bonferroni','-log10 (Wald-test p value)', '-log10 (Adjusted Wald-test p value)'))+
    scale_x_continuous(n.breaks=10)+
    labs(title=str_wrap(str_c('Multivariate Cox Regression analysis for ', nrow(multivariate_results), ' tests')),caption=str_c(mtc, ' p-value Threshold Indicated; Error Bars = 95% CI'))+
    theme(legend.position="bottom")+
     guides(col=guide_legend(nrow=1, byrow=TRUE)) 
  
  print(multivariate_plot)
  ggsave(str_c(plot_output_path, 'cox_multivariate_', output_name,'.png'), dpi=600, width=9, height=6)
  
  return(multivariate_results)
}

multivariate_coxph_plotter(multivariate_cox_results, '../PLOTS/UKB/4_SURVIVAL/2_COXPH/', 'ntprobnp_hrc_alloutcomes_fdr5')
multivariate_coxph_plotter(multivariate_cox_results, '../PLOTS/UKB/4_SURVIVAL/2_COXPH/', 'ntprobnp_hrc_alloutcomes_bonferroni', FDR=F)
```
