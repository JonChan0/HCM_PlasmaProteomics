---
title: "Univariate Survival Analysis - UKB PPP"
author: "Jonathan Chan"
date: "`r Sys.Date()`"
output: 
  html_document:
    code_folding: hide   
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(readxl)
library(viridis)
library(ggtext)
library(plotly)
library(ggrepel)
library(survival)
library(survminer)
rm(list=ls())

theme_set(theme_classic())
```

This performs univariate survival analysis using categorical variables on certain subsets within the UKB PPP subset.

## Import Predictor Data

```{r}
rcmm_cov<- T

instance <- '3_TOTAL'
# instance <- '1_I0'
# instance <- '2_5Y'
# instance <- '4_NEGTOTAL' #Those who are never HCM or HF patients

#This is derived from `UKB_Plasma_Proteomics_Analysis.Rmd` and contains the HCM cases corresponding to the particular instance (I0; 5Y or Total)
if(isTRUE(rcmm_cov)){
  ukb_pp_hcm_cov2 <- read_tsv(str_c('./DATA/UKB/PROCESSED/',instance,'/ukb_cmpanelpp_hcm_covariates_bp_t2d_smoking_rcmmcov.tsv',collapse=''))
} else {
  ukb_pp_hcm_cov2 <- read_tsv(str_c('./DATA/UKB/PROCESSED/',instance,'/ukb_cmpanelpp_hcm_covariates_bp_t2d_smoking.tsv',collapse=''))
}

 ukb_pp_hcm_cov2 <- ukb_pp_hcm_cov2 %>%
  mutate(smoking=factor(smoking, levels=c('Never','Previous','Current')))

if (instance %in% c('1_I0','2_5Y','3_TOTAL')) {
 ukb_pp_hcm_cov2 <- ukb_pp_hcm_cov2 %>%
  filter(hcm==T)
} else if (instance == '4_NEGTOTAL'){
  hf_eid <- read_csv('./DATA/UKB/RAP/Cases/ukb_rap_HF_20240209.csv')
  colnames(hf_eid) <- 'ID'

  ukb_pp_hcm_cov2 <- ukb_pp_hcm_cov2 %>%
    mutate(hf = ifelse(eid %in% hf_eid$ID, T,F)) %>%
    filter(hcm==F, hf==F)
}
```

## Import Outcome Data

This looks at the number of events which occur within the 103 HCM cases who have plasma proteomic data.

For the plasma proteomic severity analysis, you will have to perform left truncation of events that happen prior to the attendance of assessment centre at instance 0 (i.e when blood samples taken).

```{r}
ukb_pp_hcm_outcome <- read_tsv('../../HCM_Severity/DATASETS/UKB/RAP/Outcomes/Processed/allukb_outcome_ages.tsv') %>%
  filter(ID %in% ukb_pp_hcm_cov2$eid) 
  
#Perform left truncation
ukb_pp_hcm_outcome <- ukb_pp_hcm_outcome %>%
  mutate(across(.cols=arrest_age_i46:HeartTransplant_mergeage, ~ifelse(.<age_attend_i0, NA,.)))%>%
  mutate(overallcomp_status = as.numeric(if_any(.cols=arrest_age_i46:HeartTransplant_mergeage, ~!is.na(.)))) #Add censoring status where event = 1 and censored (i.e lost to follow-up or end date i.e 2024-02-09) = 0

sum(ukb_pp_hcm_outcome$overallcomp_status) 
#65 of the 103 overall cases have events in the overall composite after left truncating at attending recruitment centre!
#17 of the 25 instance 0 cases

knitr::kable(tibble('Variable'=colnames(ukb_pp_hcm_outcome),'NonNA_Counts'=map_int(ukb_pp_hcm_outcome, ~sum(!is.na(.)))) %>% arrange(desc(NonNA_Counts)))
View(tibble('Variable'=colnames(ukb_pp_hcm_outcome),'NonNA_Counts'=map_int(ukb_pp_hcm_outcome, ~sum(!is.na(.)))) %>% arrange(desc(NonNA_Counts)))

#Derive the age for overall composite
ukb_pp_hcm_outcome <- ukb_pp_hcm_outcome %>%
  rowwise() %>%
  mutate(overallcomp_age = min(c_across(arrest_age_i46:HeartTransplant_mergeage),na.rm=T)) %>% #Take the earliest date of any occurrence in the overall composite
  mutate(overallcomp_age = ifelse(overallcomp_status==T, overallcomp_age, censoring_age)) %>% #If censored i.e not event, then take the censoring age. 
  ungroup()
```

Repeat for the other composite outcomes beyond the overall composite i.e VA and HF composites.

```{r}
#For the ventricular arrhytmia composite
ukb_pp_hcm_outcome <- ukb_pp_hcm_outcome %>%
  mutate(vacomp_status = as.numeric(if_any(c('arrest_age_i46','scd_age_i46.1','ICDImplant_mergeage'), ~!is.na(.))))%>%
  rowwise() %>%
  mutate(vacomp_age = min(c_across(c('arrest_age_i46','scd_age_i46.1','ICDImplant_mergeage')),na.rm=T)) %>% #Take the earliest date of any occurrence in the composite
  mutate(vacomp_age = ifelse(vacomp_status==T, vacomp_age, censoring_age)) %>% #If censored i.e not event, then take the censoring age. 
  ungroup()

#For the HF composite
ukb_pp_hcm_outcome <- ukb_pp_hcm_outcome %>%
  mutate(hfcomp_status = as.numeric(if_any(c('hf_age_i50','HeartTransplant_mergeage'), ~!is.na(.))))%>%
  rowwise() %>%
  mutate(hfcomp_age = min(c_across(c('hf_age_i50','HeartTransplant_mergeage')),na.rm=T)) %>% #Take the earliest date of any occurrence in the composite
  mutate(hfcomp_age = ifelse(hfcomp_status==T, hfcomp_age, censoring_age)) %>% #If censored i.e not event, then take the censoring age. 
  ungroup()

#For AF only outcome
ukb_pp_hcm_outcome <- ukb_pp_hcm_outcome %>%
  mutate(af_status = as.numeric(if_any(c('af_age_i48'), ~!is.na(.))))%>%
  rowwise() %>%
  mutate(af_age = af_age_i48) %>% #Take the earliest date of any occurrence in the composite
  mutate(af_age = ifelse(af_status==T, af_age, censoring_age)) %>% #If censored i.e not event, then take the censoring age. 
  ungroup()

```

```{r}
#Merge the covariates with the outcome
ukb_tb <- ukb_pp_hcm_outcome %>%
  left_join(ukb_pp_hcm_cov2, by=c('ID'='eid'))

#rm(ukb_pp_hcm_cov2, ukb_pp_hcm_outcome)
```



## Continuous Variable Binning

This enables you to select continuous variables to bin into groups/categorical variables for plotting of Kaplan Meier analyses.

This is required for all the 

```{r}
contvar_binner <- function(input_tb, variable, threshold, signif=F){ #Assumes split into two groups
  newcolname <- str_c(variable,'_categorical')
  
  output <- mutate(input_tb,
                   temp=ifelse(eval(parse(text=variable)) >= threshold, str_c('>= ', threshold), str_c('< ', threshold)))
  colnames(output)[ncol(output)] <- newcolname
  
  return(output)
}

ukb_tb <- contvar_binner(ukb_tb, 'ntprobnp', signif(quantile(ukb_tb$ntprobnp,probs=0.75,na.rm=T),3)) %>%
  contvar_binner('hrc',signif(quantile(ukb_tb$hrc,probs=0.75,na.rm=T),3))
# %>%
  # contvar_binner('ace2',signif(quantile(ukb_tb$hrc,probs=0.75,na.rm=T),3))
```


## Kaplan Meier Survival Curves

This conducts some univariate analysis on categorical variables by plotting Kaplan-Meier survival curves for each category and performing log-rank test (non-parametric but also univariate).

The p-values and confidence intervals for difference between the groups on the plots arises from the regular log-rank test.

Such variables include

- Sex

I also change the y-axis to output cumulative incidence of events as well as cumulative hazard (number of events that would be expected for each individual by time t if the event were a repeatable process).

```{r kaplan_meier, fig.width=9, fig.height=10, message=F, warning=F}
km_survival_curv_plotter <- function(input_tb, categorical_var, status, outcome_var, plot_output_folder){ #outcome_var = Define the column for age at first occurence of selected outcome of interest
  
  print(str_c('Plotting Kaplan Meier survival curves for', deparse(substitute(categorical_var)),sep=' '))
    
    plot_types <- c('pct','event', 'cumhaz')
    
    for (type in plot_types){
    
      params <- list(fun.time = substitute(outcome_var),
    fun.event = substitute(status),
    grouping = substitute(categorical_var), 
    fun.dat = substitute(input_tb),
    type=type)
          
          plot <- substitute(ggsurvplot(
      fit= survfit(Surv(time = fun.time, event = fun.event) ~ grouping, data = fun.dat),
      fun=type,
      pval=T, conf.int=T, risk.table='abs_pct',risk.table.col='strata',linetype='strata', surv.median.line='hv',xlab='Age',ncensor.plot=T), params)
    
    plot <- eval.parent(plot)
  
    print(plot)
    
    pdf(str_c(plot_output_folder,deparse(substitute(categorical_var)),'_kaplan_',type,'.pdf'), width=12, height=9)
    print(plot, newpage=F)
    dev.off()
    }
}
```


```{r kaplan_meier, fig.width=9, fig.height=10, message=F, warning=F}
outcomes_of_interest <- c('1_VA','2_HF','3_OV','4_AF')

if(isTRUE(rcmm_cov)){
  plotpaths <- str_c('./OUTPUT/UKB/PLOTS/4_SURVIVAL/1_UNIVARIATE_KM/',instance,'/', outcomes_of_interest,'/rcmm_cov/') #Need to run separate results because 103 cases -> 100 cases when using expanded covariates
} else{
  plotpaths <- str_c('./OUTPUT/UKB/PLOTS/4_SURVIVAL/1_UNIVARIATE_KM/',instance,'/', outcomes_of_interest,'/') 
}


#Run for UKB - Overall Composite
km_survival_curv_plotter(ukb_tb,sex,overallcomp_status, overallcomp_age, plotpaths[3]) #Using sex
km_survival_curv_plotter(ukb_tb,ntprobnp_categorical,overallcomp_status,overallcomp_age, plotpaths[3]) #Using top 25% vs. bottom 75% of NTproBNP
km_survival_curv_plotter(ukb_tb,hrc_categorical,overallcomp_status,overallcomp_age, plotpaths[3]) #Using top 25% vs. bottom 75% of HRC

#Run for UKB - HF Composite
km_survival_curv_plotter(ukb_tb,sex,hfcomp_status, hfcomp_age, plotpaths[2]) #Using sex
km_survival_curv_plotter(ukb_tb,ntprobnp_categorical,hfcomp_status,hfcomp_age, plotpaths[2]) #Using top 25% vs. bottom 75% of NTproBNP
km_survival_curv_plotter(ukb_tb,hrc_categorical,hfcomp_status,hfcomp_age, plotpaths[2]) #Using top 25% vs. bottom 75% of HRC

#Run for UKB - VA Composite
km_survival_curv_plotter(ukb_tb,sex,vacomp_status, vacomp_age, plotpaths[1]) #Using sex
km_survival_curv_plotter(ukb_tb,ntprobnp_categorical,vacomp_status,vacomp_age, plotpaths[1]) #Using top 25% vs. bottom 75% of NTproBNP
km_survival_curv_plotter(ukb_tb,hrc_categorical,vacomp_status,vacomp_age, plotpaths[1]) #Using top 25% vs. bottom 75% of HRC

#Run for UKB - AF
km_survival_curv_plotter(ukb_tb,hrc_categorical,af_status,af_age, plotpaths[4]) #Using top 25% vs. bottom 75% of HRC
```
# Cox Regression

This is used to model the survival function (via the hazard function) for event composite Y with regards to covariates + plasma protein X (i.e marginal models).

I will limit the plasma proteins to a select few which passed the Bonferroni correction e.g

- NTproBNP: positive control
- HRC: novel biomarker

## Univariate Cox Regression

This applies Cox regression to each of the predictors individually.

To interpret the summary results:

- z refers to Wald test statistic (coef/se(coef)) to evaluate if the beta i.e coefficient is statistically significantly different from 0.
- p-value refers to Wald-test derived p-value

- Coefficient value and exp(coef) i.e hazard ratio reflects the change in hazard with each unit increase in predictor.
  * Hazard ratio can be interpreted as e.g hazard ratio of 0.59 means hazard reduced by 41% while hazard ratio of 1.41 means hazard increased by 41%.
- Confidence intervals of hazard ratios also given.

- Concordance i.e C-statistic is ~ AUC in that values of c near 0.5 indicate that the predictions are no better than a coin flip in determining which patient will live longer. Values near 1 indicate that the risk scores are good at determining which of two patients will have the disease first.
  * Crudely put, concordance shows your ability to predict who of a pair will die sooner, but not necessarily how much sooner or what proportion of the variance of event times is explained by the model.

- Global statistical significance of model (i.e for overall model including all predictors)
  * LRT preferred at smaller sample sizes but all 3x tests are asymptotically equivalent at large N

```{r univariate_cox, message=F, warning=F}
# coxph_univariate <- function(input_tb, predictor_var,status, outcome_var){
#   
#     params <- list(fun.time = substitute(eval(parse(text=outcome_var))),
#     fun.event = substitute(eval(parse(text=status))),
#     grouping = substitute(eval(parse(text=predictor_var))), 
#     data = substitute(input_tb))
#     
#     coxph <- substitute(coxph(Surv(fun.time,fun.event)~grouping, data), params)
#     coxph <- eval.parent(coxph)
#     
#     print(str_c('Univariate Cox Regression performed on ', predictor_var, ' variable on ', outcome_var))
#     
#     x <- summary(coxph)
#     #print(x)
#     
#     p.value<-signif(x$wald["pvalue"], digits=3)
#     wald.test<-signif(x$wald["test"], digits=3)
#     beta<-signif(x$coef[1], digits=3);#coeficient beta
#     se_beta <- signif(x$coef[3], digits=3)
#     HR <-signif(x$coef[2], digits=3);#exp(beta)
#     HR.confint.lower <- signif(x$conf.int[,"lower .95"], 3)
#     HR.confint.upper <- signif(x$conf.int[,"upper .95"],3)
#     res<-c(beta, se_beta, HR, HR.confint.lower, HR.confint.upper, wald.test, p.value)
#     names(res)<-c("beta", 'se_beta', "HR", "Lower_95CI_HR","Upper_95CI_HR", "wald.test", 
#                   "p.value")
#     
#     return(res)
# }


```


```{r univariate_cox_ukb, message=F, warning=F}
#For UKB
if(isTRUE(rcmm_cov)){
  covariates <- c('sex','bmi','pc1','pc2','pc3','pc4','pc5','dbp','smoking','t2d', 'Townsend', 'eGFR', 'ldl')
}else {
  covariates <- c('sex','bmi','pc1','pc2','pc3','pc4','pc5','dbp','smoking','t2d')
}

pp <- c('ntprobnp','hrc') #For Instance 0
# pp <- c('ntprobnp','ace2') # For 5Y cases
statuses <- c('vacomp_status','hfcomp_status','overallcomp_status')
surv_ages <- c('vacomp_age','hfcomp_age','overallcomp_age')

# univariate_cox_results <- c(
#   map(pp, ~coxph_univariate(ukb_tb,.,statuses[1],surv_ages[1])),
#   map(pp, ~coxph_univariate(ukb_tb,.,statuses[2],surv_ages[2])),
#   map(pp, ~coxph_univariate(ukb_tb,.,statuses[3],surv_ages[3]))
# )
# 
# names(univariate_cox_results) <- (expand_grid(pp,surv_ages) %>% mutate(surv_ages = factor(surv_ages, levels=c('vacomp_age','hfcomp_age','overallcomp_age'))) %>% arrange(surv_ages) %>% mutate(name = str_c(pp, surv_ages, sep='_x_')))$name
```

I also plot the results all together on a single plot of -log10(pvalue) vs. hazard ratio.

```{r univariate_plot, fig.width=9, fig.height=6}
# univariate_coxph_plotter <- function(univariate_results, plot_output_path, output_name, outcome_levels=c('VA','HF','OVERALL'), FDR=5){
#   
#   univariate_tb <- enframe(univariate_results)%>%
#     unnest(value) %>%
#     mutate(metric=rep(c("beta", 'se_beta', "HR", "Lower_95CI_HR","Upper_95CI_HR", "wald.test", 
#                     "p.value"),length(univariate_results))) %>%
#     pivot_wider(names_from=metric, values_from=value) %>%
#     dplyr::rename(var=name) %>%
#     mutate(label=var) %>%
#     #mutate(label=predictors_xlabel_tb$Label[match(var, predictors_xlabel_tb$Variable)])
#     arrange(label) %>%
#     mutate(predictor=str_to_upper(str_match(label,'(.+)_x_')[,2])) %>%
#     mutate(outcome = factor(
#       str_to_upper(str_match(label,'_x_(.+)comp_age')[,2]),levels=outcome_levels, ordered=T
#     ))
#   
#   if (!is.numeric(FDR)){ #Apply Bonferroni
#     pval_threshold = 0.05/length(univariate_results)
#     mtc <- 'Bonferroni'
#   } else{
#     univariate_tb <- mutate(univariate_tb, p.value=p.adjust(p.value, method='BH'))
#     pval_threshold <- FDR/100
#     mtc <- str_c('FDR ',FDR, '%',sep='')
#   }
# 
#   univariate_plot <- ggplot(univariate_tb, aes(HR,-log10(p.value)))+
#     geom_vline(xintercept=1, linetype='dashed',alpha=0.5)+
#     geom_hline(yintercept=-log10(pval_threshold), linetype='dashed', alpha=0.5)+
#     geom_point(aes(col=predictor, shape=outcome),alpha=0.75)+
#     geom_errorbar(aes(xmin=Lower_95CI_HR, xmax=Upper_95CI_HR,col=predictor, shape=outcome),alpha=0.75)+
#     geom_text_repel(aes(label=HR))+
#     scale_colour_brewer(name='Predictor',palette='Dark2')+
#     scale_shape_discrete(name='Outcome')+
#     xlab('Hazard Ratio')+
#     ylab(ifelse(mtc=='Bonferroni','-log10 (Wald-test p value)', '-log10 (Adjusted Wald-test p value)'))+
#     scale_x_continuous(n.breaks=10)+
#     labs(title=str_wrap(str_c('Univariate Cox Regression analysis for ', length(univariate_results), ' tests')),caption=str_c(mtc, ' p-value Threshold Indicated; Error Bars = 95% CI'))+
#     theme(legend.position="bottom")+
#      guides(col=guide_legend(nrow=1, byrow=TRUE)) 
#   
#   print(univariate_plot)
#   ggsave(str_c(plot_output_path, 'cox_univariate_', output_name,'.png'), dpi=600, width=9, height=6)
#   
#   return(univariate_tb)
# }
```


```{r univariate_plot, fig.width=9, fig.height=6}
# univariate_coxph_plotter(univariate_cox_results, '../OUTPUT/UKB/PLOTS/4_SURVIVAL/2_COXPH/', 'ntprobnp_hrc_alloutcomes_fdr5')
# univariate_coxph_plotter(univariate_cox_results, '../OUTPUT/UKB/PLOTS/4_SURVIVAL/2_COXPH/', 'ntprobnp_hrc_alloutcomes_bonferroni', FDR=F)
```


## Multivariate Cox Regression

Here I perform multivariate Cox regression using covariates and with each of the plasma proteins of interest modelled marginally.

```{r multivariate_cox, message=F, warning=F}
multivariate_cox <- function(input_tb, marginal_predictor, covariates, status, outcome_var, outcome_levels=c('VA','HF','OVERALL'), return_predictor_results_only=T, return_model=F){ #Return only the coefficient and p-values for the marginal_predictor
  
  x <- str_c(c(covariates,marginal_predictor), collapse='+')
  y <- str_c('Surv(',outcome_var,',',status,')')
  formula <- as.formula(paste(y,'~',x))
  
  multivariate_cox <- coxph(formula, data=input_tb)
  print(summary(multivariate_cox))
  
  x<- summary(multivariate_cox)
  
  if(isTRUE(return_model)){
    return(multivariate_cox)
  }
  
  if(isFALSE(return_predictor_results_only)){
  
  p.value<-signif(x$coef[1:nrow(x$coef),5], digits=3)
  beta<-signif(x$coef[1:nrow(x$coef),1], digits=3);#coeficient beta
  HR <-signif(x$coef[1:nrow(x$coef),2], digits=3);#exp(beta) = hazard ratio
  HR.confint.lower <- signif(x$conf.int[,"lower .95"], 3)
  HR.confint.upper <- signif(x$conf.int[,"upper .95"],3)
  se_beta <- signif(x$coef[1:nrow(x$coef),3], digits=3)
  vars <- rownames(x$coef)
    
  } else{
      p.value<-signif(x$coef[nrow(x$coef),5], digits=3)
  beta<-signif(x$coef[nrow(x$coef),1], digits=3);#coeficient beta
  HR <-signif(x$coef[nrow(x$coef),2], digits=3);#exp(beta) = hazard ratio
  HR.confint.lower <- signif(x$conf.int[,"lower .95"][nrow(x$coef)], 3)
  HR.confint.upper <- signif(x$conf.int[,"upper .95"][nrow(x$coef)],3)
  se_beta <- signif(x$coef[nrow(x$coef),3], digits=3)
  vars <- rownames(x$coef)[nrow(x$coef)]

  }
  
  res<-bind_cols(vars,beta, se_beta, HR, HR.confint.lower, HR.confint.upper, p.value) %>%
    mutate(predictor=str_to_upper(vars)) %>%
    mutate(outcome = factor(
      str_to_upper(str_match(outcome_var,'(.+)comp_age')[,2]),levels=outcome_levels, ordered=T
    ))
  
  names(res)<-c('var',"beta",'se_beta', "HR", "Lower_95CI_HR","Upper_95CI_HR", 
            "p.value", 'predictor','outcome')
  
  return(res)
}
```


```{r multivariate_cox, message=F, warning=F}
#Run marginal Cox regression models for each plasma protein with each outcome of interest
multivariate_cox_results <- c(
  map(pp, ~multivariate_cox(ukb_tb,.,covariates,statuses[1],surv_ages[1])),
  map(pp, ~multivariate_cox(ukb_tb,.,covariates,statuses[2],surv_ages[2])),
  map(pp, ~multivariate_cox(ukb_tb,.,covariates,statuses[3],surv_ages[3]))
) %>%
  bind_rows() %>%
  filter(!is.na(p.value))

#Actually output the multivariate Cox model objects themselves
multivariate_cox_models <- c(
  map(pp, ~multivariate_cox(ukb_tb,.,covariates,statuses[1],surv_ages[1], return_model=T)),
  map(pp, ~multivariate_cox(ukb_tb,.,covariates,statuses[2],surv_ages[2], return_model=T)),
  map(pp, ~multivariate_cox(ukb_tb,.,covariates,statuses[3],surv_ages[3], return_model=T))
)
names(multivariate_cox_models) <-(expand_grid(pp,surv_ages) %>% mutate(surv_ages = factor(surv_ages, levels=c('vacomp_age','hfcomp_age','overallcomp_age'))) %>% arrange(surv_ages) %>% mutate(name = str_c(pp, surv_ages, sep='_x_')))$name

#Run joint Cox regression models (i.e all plasma proteins modelled together)
#Evaluate pairwise correlation between NTproBNP and HRC
cor(ukb_tb$ntprobnp, ukb_tb$hrc, method='spearman', use='pairwise.complete.obs') #0.6 correlation so Cox regression not suitable model for such collinearity
cor(ukb_tb$ntprobnp, ukb_tb$ace2, method='spearman', use='pairwise.complete.obs')


```
Try with only HRC x AF outcome.

```{r}
multivariate_cox(input_tb = ukb_tb, marginal_predictor = 'hrc',covariates = covariates,status = 'af_status',outcome_var = 'af_age',outcome_levels = 'AF')
```


#### Multivariate Summary Plotting

Now plot a summary plot of the results for each predictor.

```{r multivariate_cox_plotter, fig.width=9, fig.height=6, message=F,warning=F}

multivariate_coxph_plotter <- function(multivariate_results, plot_output_path, output_name, FDR=5){
  
  if (!is.numeric(FDR)){ #Apply Bonferroni
    pval_threshold = 0.05/nrow(multivariate_results)
    mtc <- 'Bonferroni'
  } else{
    multivariate_results <- mutate(multivariate_results, p.value=p.adjust(p.value, method='BH'))
    pval_threshold <- FDR/100
    mtc <- str_c('FDR ',FDR, '%',sep='')
  }

  multivariate_plot <- ggplot(multivariate_results, aes(HR,-log10(p.value)))+
    geom_vline(xintercept=1, linetype='dashed',alpha=0.5)+
    geom_hline(yintercept=-log10(pval_threshold), linetype='dashed', alpha=0.5)+
    geom_point(aes(col=predictor, shape=outcome),alpha=0.75)+
    geom_errorbarh(aes(xmin=Lower_95CI_HR, xmax=Upper_95CI_HR,col=predictor, shape=outcome),alpha=0.75, height=0.1)+
    geom_text_repel(aes(label=HR))+
    scale_colour_brewer(name='Predictor',palette='Dark2')+
    scale_shape_discrete(name='Outcome')+
    xlab('Hazard Ratio')+
    ylab(ifelse(mtc=='Bonferroni','-log10 (Wald-test p value)', '-log10 (Adjusted Wald-test p value)'))+
    scale_x_continuous(n.breaks=10)+
    labs(title=str_wrap(str_c('Multivariate Cox Regression analysis for ', nrow(multivariate_results), ' tests')),caption=str_c(mtc, ' p-value Threshold Indicated; Error Bars = 95% CI'))+
    theme(legend.position="bottom")+
     guides(col=guide_legend(nrow=1, byrow=TRUE)) 
  
  print(multivariate_plot)
  ggsave(str_c(plot_output_path, 'cox_multivariate_', output_name,'.png'), dpi=600, width=9, height=6)
  
  return(multivariate_results)
}

if(isTRUE(rcmm_cov)){
  path <- str_c('./OUTPUT/UKB/PLOTS/4_SURVIVAL/2_COXPH/',instance,'/rcmm_cov/')
} else{
  str_c('./OUTPUT/UKB/PLOTS/4_SURVIVAL/2_COXPH/',instance,'/')
}

multivariate_coxph_plotter(multivariate_cox_results,path, 'ntprobnp_hrc_alloutcomes_fdr5')
multivariate_coxph_plotter(multivariate_cox_results, path, 'ntprobnp_hrc_alloutcomes_bonferroni', FDR=F)

```
### Cox Assumptions

This tests the assumptions of the Cox regression model.

#### Proportional Hazards Assumption

This assumption implies the **HR measuring the effect of any predictor is constant over time**.

1. Proportional Hazards assumption by testing for independence between the scaled Schoenfeld residual and the timescale.

Each row represents the statistical test that the coefficient value does NOT change with respect to time (null hypothesis).
However, you must take into account the multiple testing burden for the individual predictors.
The GLOBAL row tests the null hypothesis that all the predictors do NOT meet the PH assumption.

The plot of horizontal line in the plot should be flat to indicate that the assumption is met.


```{r ph_assumptions,fig.width=9, fig.height=6}

ph_assumption_tester <- function(model, plot_output_path='', plot=T){
  print(plot_output_path)
  
  ph_assumption_test <- cox.zph(model)
  print(ph_assumption_test)

  if(isTRUE(plot)){
     walk(rownames(ph_assumption_test$table)[1:nrow(ph_assumption_test$table)-1], ~ggcoxzph(ph_assumption_test, var=.) %>% print() 
          #%>%
          #  ggsave(filename=str_c(plot_output_path, '_ss.png',.), dpi=600)
          )
  }
 
  return(ph_assumption_test)
}

ph_assumption_paths <- (expand_grid(surv_ages, pp) %>% mutate(path = str_c('OUTPUT/UKB/PLOTS/4_SURVIVAL/2_COXPH/',instance,'/ASS/', str_match(surv_ages, '^(.+)_age')[,2],'_', pp)))$path
multivariate_cox_ph <- map2(multivariate_cox_models, ph_assumption_paths, ~ph_assumption_tester(.x, .y))
```
Sex appears to violate the PH assumption for HRC/NTproBNP x Overall Composite so I attempt to correct this here.

The two main ways to correct for violation of this proportional hazards assumption is

1. Inclusion of an interaction term between predictor and the timescale used
2. Stratification of a categorical predictor term

The interaction term inclusion relaxes the PH assumption by accounting for a change in the coefficient (i.e hazard ratio) over the timescale e.g 
At age 30, the hazard ratio associated with 1-year increase in age of diagnosis = 0.9 but at age 50, this might be 0.95.

However, the interaction term itself assumes either a linear or other relationship between the coefficient and the timescale.

It is also important to note that **by including the interaction term, the main effect term no longer represents the main effect. It instead represents the effect at timescale=0**.
So with age at diagnosis, the hazard ratio of 0.88 represents the hazard ratio associated with 1-unit increase in diagnosis_age at birth.

```{r fix_ph_assumption}
ph_assumption_fixer <- function(data_tb, pp_of_interest, y_formula ="Surv(overallcomp_age,overallcomp_status)", predictors_to_fix=c('sex'), other_covariates = c('bmi','pc1','pc2','pc3','pc4','pc5','dbp','smoking','t2d','Townsend','eGFR','ldl'), model_return=F){

  predictors_of_interest <- c(str_c(predictors_to_fix, '2'), other_covariates, pp_of_interest,str_c('tt(',predictors_to_fix, '2)'))
  
  x <- str_c(predictors_of_interest, collapse='+')
  y <- y_formula
  formula <- as.formula(paste(y,'~',x))
  
    for (i in seq_along(predictors_to_fix)){
      data_tb[str_c(predictors_to_fix[i], '2')] <- data_tb[predictors_to_fix[i]]
    
  }
  
  if ('sex' %in% predictors_to_fix){
    data_tb <- mutate(data_tb, sex2=ifelse(sex=='Male',1,0))
  } 
  

  multivariate_cox_interactions <- coxph(formula, data=data_tb, tt=function(x,t,...) x*t) #Adds an interaction term between timescale and the predictor to try fix the PH assumption violation
  print(summary(multivariate_cox_interactions))
  
  #Double check if the interaction term is valid
  
  # print(str_c('Showing hazard ratio associated with having Male sex over timescale with the inflection timepoint = ',signif(-1*coef(multivariate_cox_interactions)["sex2"] /
  #   coef(multivariate_cox_interactions)["tt(sex2)"]),3)) #This is the inflection age at which the gradient is 0 i.e no variation in hazard ratio over time
  
  for(i in seq_along(predictors_to_fix)){
#This plots the sum of the baseline hazard ratio (i.e main effect when timescale=0) + the time-dependent hazard ratio at each time x
  SUB    <- ukb_tb$overallcomp_status == 1
  TIME   <- seq(min(ukb_tb$overallcomp_age[SUB]), #Assume overallcomp
                max(ukb_tb$overallcomp_age[SUB]), 1)
  BETA   <- coef(multivariate_cox_interactions)[str_c(predictors_to_fix[i],'2')]
  BETATT <- coef(multivariate_cox_interactions)[str_c('tt(',predictors_to_fix[i],'2)')]
  AHR    <- exp(BETA + BETATT*TIME)
  
  plot(TIME, AHR, type = "l", xlab='Age', ylab=str_c('Hazard Ratio of ', predictors_to_fix[i]))
  abline(h = 1, lty = 2, col = "darkgray")
  abline(v = -1*BETA/BETATT, lty = 2, col = "darkgray")
  }
  
  if(isTRUE(model_return)){
    return(multivariate_cox_interactions)
  }
  
  #This returns the coefficient values from the CoxPH model fitted
  
  x <- summary(multivariate_cox_interactions)
    
  p.value<-signif(x$coef[1:nrow(x$coef),5], digits=3)
  beta<-signif(x$coef[1:nrow(x$coef),1], digits=3);#coeficient beta
  HR <-signif(x$coef[1:nrow(x$coef),2], digits=3);#exp(beta) = hazard ratio
  HR.confint.lower <- signif(x$conf.int[,"lower .95"], 3)
  HR.confint.upper <- signif(x$conf.int[,"upper .95"],3)
  se_beta <- signif(x$coef[1:nrow(x$coef),3], digits=3)
  vars <- rownames(x$coef)
  
  res<-bind_cols(vars,beta, se_beta, HR, HR.confint.lower, HR.confint.upper, p.value) %>%
    mutate(predictor=str_to_upper(vars)) 
  
  names(res)<-c('var',"beta",'se_beta', "HR", "Lower_95CI_HR","Upper_95CI_HR", 
            "p.value", 'predictor')
  
  return(res)

}

# td_covar_ntprobnp_overallcomp <- ph_assumption_fixer(ukb_tb, 'ntprobnp') %>% mutate(outcome='OVERALL')
# td_covar_hrc_overallcomp <-ph_assumption_fixer(ukb_tb, 'hrc', predictors_to_fix=c('sex','bmi')) %>% mutate(outcome='OVERALL')
# 
# #Update multivariate cox results with these adjusted 
# multivariate_cox_results_timeadj <- multivariate_cox_results %>%
#   filter(!(var %in% c('ntprobnp','hrc') & outcome=='OVERALL')) %>%
#   bind_rows(filter(td_covar_ntprobnp_overallcomp, var=='ntprobnp')) %>%
#   bind_rows(filter(td_covar_hrc_overallcomp, var=='hrc')) %>%
#   mutate(outcome=factor(outcome, levels=c('VA','HF','OVERALL')))
# 
# rm(list=ls(pattern='td_covar'))
# 
# #Replot the summary
# multivariate_coxph_plotter(multivariate_cox_results_timeadj,str_c('./OUTPUT/UKB/PLOTS/4_SURVIVAL/2_COXPH/',instance,'/'), 'ntprobnp_hrc_alloutcomes_fdr5_timeadj')
# multivariate_coxph_plotter(multivariate_cox_results_timeadj,str_c('./OUTPUT/UKB/PLOTS/4_SURVIVAL/2_COXPH/',instance,'/'), 'ntprobnp_hrc_alloutcomes_bonferroni_timeadj', FDR=F)
# 
# #These output the models itself
# td_covar_ntprobnp_overallcomp_model <- ph_assumption_fixer(ukb_tb, 'ntprobnp', model_return=T)
# td_covar_hrc_overallcomp_model <-ph_assumption_fixer(ukb_tb, 'hrc', predictors_to_fix=c('sex','bmi'), model_return=T)

```

#### Influential Observations

This looks at the influential observations e.g outliers/high-leverage observations which may influence the model.

The first plots show the estimated changes in the regression coefficients by deleting each observation in turn.
Ideally, you want the largest y-values in these plots to be << actual coefficients for the predictor. A large value would indicate that deleting that observation shifts the coefficient substantially (relative to the actual coefficient).

```{r dfbeta, fig.width=15, fig.height=15, message=F, warning=F}

print(summary(td_covar_ntprobnp_overallcomp_model)) #These are the actual coefficients

#This is for the NTproBNP x overall comp
print(ggcoxdiagnostics(td_covar_ntprobnp_overallcomp_model, type = "dfbeta",
                 linear.predictions = FALSE, ggtheme = theme_classic()))

print(summary(td_covar_hrc_overallcomp_model)) #These are the actual coefficients

#This is for the HRCx overall comp
print(ggcoxdiagnostics(td_covar_hrc_overallcomp_model, type = "dfbeta",
                 linear.predictions = FALSE, ggtheme = theme_classic()))
```

The second plots show the deviance residuals such that positive values = individuals that 'died too soon' compared to expected survival time, negative values = individuals that 'lived too long' so presence of very large or very small values indicates outliers.

Ideally the residuals should be symmetrical about 0.

```{r deviance, fig.width=7, fig.height=7, message=F, warning=F}
# print(ggcoxdiagnostics(multivariate_cox, type = "deviance",
#                  linear.predictions = FALSE, ggtheme = theme_bw()))
```

#### Linearity Assumption

I also test for non-linearity as the Cox regression model assumes linear relationship between the response and the predictor variables.

This is tested for the **continuous predictors** by plotting the Martingale residuals against the continuous predictors. Their values range from -Infinity to +1 such that a value near 1 suggests individuals that 'died too soon' and a large negative value indicates individuals that 'lived too long'.

The expected line for a linear relationship = straight horizontal line at y=0.

Note that linearity does not influence categorical variables.

The resultant line (fitted with loess) should be linear to satisfy the linearity assumption.

```{r martingale, fig.width=7, fig.height=7}
martingale_plotter <- function(input_tb, var, y_formula="Surv(overallcomp_age, overallcomp_status)"){

  #input_tb <- filter(input_tb, !is.na(var))

  x <- str_c(var,paste('log(',var,')',sep=''),paste('I(sqrt(',var,'))',sep=''), paste('I(',var,'^2)',sep=''),sep='+')
  y <- y_formula
  formula <- as.formula(paste(y,'~',x))

  ggcoxfunctional(formula,data=filter(input_tb, !is.na(var)))
}

martingale_plotter(ukb_tb, 'bmi')

#Because the pp values are inverse-rank normalised, there are negative values so only check squared and normal

ggcoxfunctional(as.formula('Surv(overallcomp_age, overallcomp_status)~ntprobnp + I(ntprobnp^2)'), data=filter(ukb_tb,!is.na(ntprobnp), ntprobnp!=0))
ggcoxfunctional(as.formula('Surv(overallcomp_age, overallcomp_status)~hrc + I(hrc^2)'), data=filter(ukb_tb,!is.na(hrc), hrc!=0))

ggcoxfunctional(as.formula('Surv(overallcomp_age, overallcomp_status)~bmi + I(bmi^2) + log(bmi) + I(sqrt(bmi))'), data=filter(ukb_tb,!is.na(bmi), bmi!=0))
```



# Archived

Age at diagnosis as well as sex appear to violate the PH assumption so I attempt to correct this here.

The two main ways to correct for violation of this proportional hazards assumption is

1. Inclusion of an interaction term between predictor and the timescale used
2. Stratification of a categorical predictor term

The interaction term inclusion relaxes the PH assumption by accounting for a change in the coefficient (i.e hazard ratio) over the timescale e.g 
At age 30, the hazard ratio associated with 1-year increase in age of diagnosis = 0.9 but at age 50, this might be 0.95.

However, the interaction term itself assumes either a linear or other relationship between the coefficient and the timescale.

It is also important to note that **by including the interaction term, the main effect term no longer represents the main effect. It instead represents the effect at timescale=0**.
So with age at diagnosis, the hazard ratio of 0.88 represents the hazard ratio associated with 1-unit increase in diagnosis_age at birth.

```{r fix_ph_assumption}
predictors_of_interest <- c('diagnosis_age2','sex2',
                            #str_c('PC',seq(1,5)),
                            'bmi','sbp','cv_prs','ALL_P_LP_LOFTEE','ALL_VUS_COMPMASK80',
                            'tt(diagnosis_age2)','tt(sex2)')

x <- str_c(predictors_of_interest, collapse='+')
y <- "Surv(lastfollowup_age,status)"
formula <- as.formula(paste(y,'~',x))

multivariate_cox_interactions <- coxph(formula, data=mutate(ukb_tb, diagnosis_age2=diagnosis_age,sex2=ifelse(sex=='Male',1,0)), tt=function(x,t,...) x*t) #Adds an interaction term between timescale and the predictor to try fix the PH assumption violation
print(summary(multivariate_cox_interactions))
```

The p-values for tt(diagnosis_age) and tt(sex2) show the statistical test for whether the interaction is significant (i.e if the linear change in the coefficient with respect to timescale is significantly different from 0). 

A significant result means that the proportional hazards assumption is indeed incorrect and there is a significant linear change in the hazard ratio with respect to timescale.

```{r fix_ph_assumption_plot_diagnosisage}
#From https://www.bookdown.org/rwnahhas/RMPH/survival-phassumption.html
#This outputs the timescale point at which the hazard ratio's direction of association changes

print(str_c('Showing hazard ratio associated with 1-unit increase in diagnosis_age over timescale with the inflection timepoint = ',
      signif(-1*coef(multivariate_cox_interactions)["diagnosis_age2"] /
  coef(multivariate_cox_interactions)["tt(diagnosis_age2)"]),3))

# Range of observed event times
SUB    <- ukb_tb$status == 1
TIME   <- seq(min(ukb_tb$lastfollowup_age[SUB]),
              max(ukb_tb$lastfollowup_age[SUB]), 1)
BETA   <- coef(multivariate_cox_interactions)["diagnosis_age2"]
BETATT <- coef(multivariate_cox_interactions)["tt(diagnosis_age2)"]
AHR    <- exp(BETA + BETATT*TIME)
plot(TIME, AHR, type = "l", xlab='Age', ylab='Hazard Ratio of Those Differing by 1-Unit in Diagnosis Age')
abline(h = 1, lty = 2, col = "darkgray")
abline(v = -1*BETA/BETATT, lty = 2, col = "darkgray")
```
The increase of the line with age shows that as the age/timescale increases, the hazard ratio associated with 1-unit increase in age of diagnosis increases. This suggests that age of diagnosis affects patients more when they are young (when a 1-unit increase in age of diagnosis has more of a protective effect).

```{r fix_ph_assumption_plot_sex2}
print(str_c('Showing hazard ratio associated with having Male sex over timescale with the inflection timepoint = ',signif(-1*coef(multivariate_cox_interactions)["sex2"] /
  coef(multivariate_cox_interactions)["tt(sex2)"]),3))


# Range of observed event times
SUB    <- ukb_tb$status == 1
TIME   <- seq(min(ukb_tb$lastfollowup_age[SUB]),
              max(ukb_tb$lastfollowup_age[SUB]), 1)
BETA   <- coef(multivariate_cox_interactions)["sex2"]
BETATT <- coef(multivariate_cox_interactions)["tt(sex2)"]
AHR    <- exp(BETA + BETATT*TIME)
plot(TIME, AHR, type = "l", xlab='Age', ylab='Hazard Ratio of having Male Sex')
abline(h = 1, lty = 2, col = "darkgray")
abline(v = -1*BETA/BETATT, lty = 2, col = "darkgray")
```
The decrease of the line with age shows that as the age/timescale increases, the hazard ratio associated with having male sex decreases towards 1. This suggests that sex affects patients more when they are young (when being Male has more of a harmful effect).

**Ultimately, by including these time interaction effects you relax the proportional hazards assumption for the Cox regression model to incorporate time-varying predictors('covariates' in survival analysis nomenclature). I replot the summary graph to show the significant predictors**

```{r replot_multivariate_cox, message=F, warning=F, fig.width=12, fig.height=6}
multivariate_cox_tb2 <- summary_cox_tb_gen(summary(multivariate_cox_interactions)) %>%
  mutate(label=predictors_xlabel_tb$Label[match(var, predictors_xlabel_tb$Variable)]) %>%
  mutate(label=ifelse(is.na(label), var, label))

multivariate_plot2 <- ggplot(filter(multivariate_cox_tb2, !str_detect(var,'PC')), aes(HR,-log10(p.value)))+ #Plot without PCs
  geom_vline(xintercept=1, linetype='dashed',alpha=0.5)+
  geom_hline(yintercept=-log10(0.05/nrow(multivariate_cox_tb2)), linetype='dashed', alpha=0.5)+
  geom_point(aes(col=label),alpha=0.75)+
  geom_errorbar(aes(xmin=Lower_95CI_HR, xmax=Upper_95CI_HR,col=label),alpha=0.75)+
  scale_colour_brewer(name='Predictor',palette='Paired')+
  geom_text_repel(aes(label=HR))+
  xlab('Hazard Ratio')+
  ylab('-log10 (Wald-test p value)')+
  scale_x_continuous(n.breaks=10)+
  labs(title=str_c('Multivariate Cox Regression analysis for ', nrow(multivariate_cox_tb2), 
                   #' (including 5 common variant PCs)', 
                   ' predictors for overall composite outcome'),caption='Bonferroni-corrected p-value threshold indicated')+
  theme(legend.position="bottom")+
   guides(col=guide_legend(nrow=4, byrow=TRUE)) 

print(multivariate_plot2)
ggsave('../OUTPUT/PLOTS/3_COXPH/2_MULTIVARIATE/UKB/multivariate_interactions_pval_hr.png', dpi=600, width=12, height=6)

rm(multivariate_plot2)
```
